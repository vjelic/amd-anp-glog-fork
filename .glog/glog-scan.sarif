{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-694fe2df-0531-4b7a-8ecc-f6c28f3df658",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee null-termination of the destination string when the source string length is greater than or equal to the destination buffer size. This can lead to buffer overflows, which can be exploited to execute arbitrary code, overwrite important data, or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, consider using safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using the `std::string` class or the `strlcpy` function if available.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` if available, or use `std::string::copy`:\n\n```cpp\nstd::string virtual_intf = devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE);\nif (virtual_intf.length() >= MAX_STR_LEN) {\n    virtual_intf.resize(MAX_STR_LEN - 1);\n}\nstd::copy(virtual_intf.begin(), virtual_intf.end(), dev.virtual_intf);\ndev.virtual_intf[virtual_intf.size()] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>` for `std::string`\n- `<algorithm>` for `std::copy`\n- `<boost/property_tree/ptree.hpp>` for `boost::property_tree::ptree::get`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-26bfeeca-34da-4263-a83a-d81010d6e916",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (buffer.size() - offset >= sizeof(planar_intf.ipv4_addr)) {\n    memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the source buffer (minus the offset) is greater than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If not, we handle the error in some way.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ea26081a-a14c-46bd-8863-8797b480e42d",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow. This can occur when the source string's length is greater than the destination buffer size. The function does not null-terminate the destination string when the source string's length is greater than or equal to the destination buffer size. This can lead to undefined behavior and potential security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that ensure null-termination and prevent buffer overflow. In C++, this can be achieved by using the `std::string` class or the `strlcpy` function if available.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` if available, or use `std::string`:\n\n```cpp\nstd::string name = intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME);\nif (name.length() >= MAX_STR_LEN) {\n    name = name.substr(0, MAX_STR_LEN - 1);\n}\nstrlcpy(pi.name, name.c_str(), MAX_STR_LEN);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<string>` for `std::string`\n- `<cstring>` for `strlcpy` (if available)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the availability of `strlcpy` may vary depending on the platform and compiler. If `strlcpy` is not available, consider using a safe string handling library or function that provides similar functionality."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-41ce96b8-452f-4845-9e2f-4b370d1774be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee that the destination string will be null-terminated if the source string is longer than the specified length. This can lead to buffer overflow vulnerabilities, which can be exploited to execute arbitrary code, cause a system crash, or expose sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using the `std::string` class or the `strlcpy` function if available.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` if available, or use `std::string::copy`:\n\n```cpp\nstd::string src = intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID);\nstd::string dest(MAX_STR_LEN - 1, '\\0');\nsrc.copy(dest.data(), dest.size());\npi.id = dest;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>` for `std::string`\n- `<map>` for `std::map`\n- `<boost/property_tree/ptree.hpp>` for `boost::property_tree::ptree`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-ed38e1c1-9b42-45fc-8b7e-221c418ee76a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the size of the source buffer, it can lead to a buffer overflow. This can overwrite adjacent memory and lead to unexpected behavior, including crashes, data corruption, and potential code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from a buffer into the `ipv6_addr` field of the `planar_intf` structure. If the size of the data in the buffer is larger than the size of `ipv6_addr`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nif (buffer.size() - offset >= sizeof(planar_intf.ipv6_addr)) {\n    memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check that the size of the data in the buffer (minus the offset) is not larger than the size of `ipv6_addr` before calling `memcpy`.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `<cstring>`: for the `memcpy` function\n- `<vector>`: if `buffer` is a `std::vector`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-cd9fb11f-7629-41f0-aab3-6d370d2f5176",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to vulnerabilities if the destination buffer is smaller than the source buffer. In the provided code snippet, if `planar_name_len` is larger than the size of `planar_intf.name`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the source buffer is larger than the destination buffer, you should either resize the destination buffer or truncate the source data to fit into the destination buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (planar_name_len <= sizeof(planar_intf.name)) {\n    memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len);\n} else {\n    // Handle error condition, e.g., throw an exception or return an error code\n}\n```\n\nIn this fix, we first check if `planar_name_len` is less than or equal to the size of `planar_intf.name`. If it is, we proceed with the `memcpy`. If it is not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>`: This library is required if `buffer` is a `std::vector`.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-93826d68-f5dd-4d22-af2a-5cf82d648bed",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (buffer.size() - offset >= virtual_intf_len) {\n    memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len);\n} else {\n    // Handle error: source data is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-51be2d47-b18d-4b7b-894a-4b1a12dc31e8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from a buffer to the `planar_intf.id` variable. If the size of the data in the buffer (defined by `planar_id_len`) is larger than the size of `planar_intf.id`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(planar_intf.id) >= planar_id_len) {\n    memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: for the `memcpy` function\n- `<vector>` or `<array>`: if `buffer` is a standard C++ container\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-2577d3cf-2c74-4bd1-bf6c-af1ad621b987",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the source is larger than the destination. In the provided code snippet, the `memcpy` function is copying data from `buffer.data() + offset` to `device.virtual_ip`. If the size of the data at `buffer.data() + offset` is larger than `device.virtual_ip`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. If the source is larger, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(device.virtual_ip) >= sizeof(buffer.data() + offset)) {\n    memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip));\n} else {\n    // Handle error\n}\n```\n\nIn this updated code, we first check if `device.virtual_ip` is large enough to hold the data at `buffer.data() + offset`. If it is, we proceed with the `memcpy` operation. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c6b9981a-e8c2-484a-bbec-2e53d7e29db6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(planar_intf.name)` with `strnlen(planar_intf.name, sizeof(planar_intf.name))`.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-eb563567-9858-4f03-b905-199471f683f5",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(planar_intf.name)` with `strnlen(planar_intf.name, sizeof(planar_intf.name))`.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-143c7cd4-1984-4af6-85f8-9ca13300538f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(planar_intf.id);\n```\n\nUse:\n\n```cpp\nstrnlen(planar_intf.id, sizeof(planar_intf.id));\n```\n\nThis will ensure that `strnlen()` does not read beyond the size of `planar_intf.id`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a1c8b7c2-82a1-4bf3-a42d-ce047807cffb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(planar_intf.id);\n```\n\nUse:\n\n```cpp\nstrnlen(planar_intf.id, sizeof(planar_intf.id));\n```\n\nThis will ensure that `strnlen()` does not read beyond the size of `planar_intf.id`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-8705759c-62fb-4b73-9a53-71a282206461",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(device.virtual_intf)`, the vulnerability arises if `device.virtual_intf` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(device.virtual_intf)` with `strnlen(device.virtual_intf, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of `device.virtual_intf`.\n\n```cpp\n#include <string.h> // for strnlen\n\n#define MAX_LENGTH 100 // replace with actual maximum length\n\nsize_t length = strnlen(device.virtual_intf, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `strnlen()` function.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-14f78204-8b52-4ca1-b846-0df864c1d867",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(device.virtual_intf)`, the vulnerability arises if `device.virtual_intf` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(device.virtual_intf)` with `strnlen(device.virtual_intf, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of `device.virtual_intf`.\n\n```cpp\n#include <string.h> // for strnlen\n\n#define MAX_LENGTH 100 // replace with actual maximum length\n\nsize_t length = strnlen(device.virtual_intf, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `strnlen()` function.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-d6d6caf0-4df1-4cf3-a170-12ef1830694f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. If the size of the memory to be allocated is controlled by the user or can be influenced by an attacker, it can lead to various security issues such as Denial of Service (DoS), Remote Code Execution (RCE), or Information Disclosure.\n\nIn the provided code snippet, the size of the memory to be allocated is determined by the `total_LNs` variable. If an attacker can control or influence this value, they could cause the program to allocate too much memory, leading to a DoS condition. Alternatively, they could cause the program to allocate too little memory, which could lead to a buffer overflow if the program then tries to store more data in the allocated memory than it can hold.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the size of the memory to be allocated is not controllable by an attacker. You should also ensure that you check the return value of `malloc` to make sure that the memory allocation was successful. If `malloc` fails, it returns a null pointer, and any attempt to use this pointer will result in undefined behavior.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (total_LNs > MAX_ALLOWED_LNS) {\n    // Handle error condition\n    return;\n}\n\nstruct RecvThreadArg *args = (struct RecvThreadArg *) malloc(total_LNs * sizeof(struct RecvThreadArg));\nif (args == NULL) {\n    // Handle error condition\n    return;\n}\n```\n\nIn this fixed code, we first check if `total_LNs` is greater than a predefined maximum allowed value (`MAX_ALLOWED_LNS`). If it is, we handle the error condition and return. After calling `malloc`, we check if the returned pointer is null, indicating that the memory allocation failed. If it is, we handle the error condition and return.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5be2c134-80d0-4604-92cb-d43aa51a95ca",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. If the size of the memory to be allocated is controlled by the user or can be influenced by an attacker, it can lead to various security issues such as Denial of Service (DoS), memory corruption, or even remote code execution.\n\nIn the provided code snippet, the size of the memory to be allocated is determined by the variable `total_LNs`. If an attacker can control the value of `total_LNs`, they can cause the program to allocate an excessively large amount of memory, leading to a DoS condition. Alternatively, they could cause the program to allocate too little memory, which could lead to buffer overflow conditions if the program later tries to store more data in the allocated space than it can hold.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the size of the memory to be allocated is not controllable by an attacker. You should validate and sanitize all input, and use safe functions that limit the size of the memory allocation.\n\n## Source Code Fix Recommendation\n\n```cpp\nsize_t total_LNs = get_total_LNs(); // get the value from a trusted source\nif (total_LNs > MAX_LNs) { // MAX_LNs is a predefined constant\n    // handle the error, e.g., by terminating the program\n    fprintf(stderr, \"Error: too many LNs\\n\");\n    exit(1);\n}\npthread_t* threads = (pthread_t*) malloc(total_LNs * sizeof(pthread_t));\nif (threads == NULL) {\n    // handle the error, e.g., by terminating the program\n    fprintf(stderr, \"Error: could not allocate memory\\n\");\n    exit(1);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `pthread.h`: for the `pthread_t` type\n- `stdlib.h`: for the `malloc` function\n- `stdio.h`: for the `fprintf` and `stderr` functions\n\n## References\n\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-dbc7f200-0be9-49d6-8fee-bd40bbfa37f8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe and can lead to vulnerabilities such as buffer overflow. This is because `strncpy` does not guarantee a null-terminated string if the source string length is greater than or equal to the destination buffer size. This can lead to undefined behavior or crashes when the string is used.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that guarantee null-termination, such as `strlcpy` or `snprintf`. If these are not available, you should manually ensure null-termination of the string.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf`:\n\n```cpp\n// Using strlcpy\nstrlcpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN);\n\n// Using snprintf\nsnprintf(connArr[accepted].peer_ip, INET_ADDRSTRLEN, \"%s\", \"unknown\");\n```\n\nIf these functions are not available, manually ensure null-termination:\n\n```cpp\nstrncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN - 1);\nconnArr[accepted].peer_ip[INET_ADDRSTRLEN - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>` or `<cstring>` for `strncpy`, `strlcpy`, or `snprintf`\n- `<netinet/in.h>` for `INET_ADDRSTRLEN`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the availability of the links is subject to the respective organizations' policies and may change over time."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-fd8a761c-5c32-47bb-bd69-bae17c3583f6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. If the size of the memory to be allocated is controlled by the user or can be influenced by an attacker, it can lead to various security issues such as Denial of Service (DoS), memory corruption, or even remote code execution.\n\nIn the provided code snippet, the size of the memory to be allocated is determined by the `total_LNs` variable. If an attacker can control or influence this value, they could cause the program to allocate an excessively large amount of memory, leading to a DoS condition. Alternatively, they could cause the program to allocate too little memory, which could lead to memory corruption if the program later tries to write more data to the allocated block than it can hold.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Validate and sanitize all user inputs: Never trust user input blindly. Always validate it to ensure it is within the expected range. In this case, you should check that the value of `total_LNs` is within a reasonable range before using it to allocate memory.\n\n2. Use functions that limit the amount of memory that can be allocated: Instead of `malloc`, consider using functions like `calloc`, which takes two arguments: the number of elements and the size of each element. This can help prevent excessively large memory allocations.\n\n3. Handle `malloc` failures: Always check if `malloc` returns `NULL`, which indicates that the memory allocation failed. If `malloc` fails, make sure to handle this error gracefully.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nif (total_LNs > MAX_CONNECTIONS) {\n    // Handle error: total_LNs is too large\n} else {\n    struct Connection* connections = (struct Connection*) malloc(total_LNs * sizeof(struct Connection));\n    if (connections == NULL) {\n        // Handle error: malloc failed\n    } else {\n        // Continue with program\n    }\n}\n```\n\nIn this code, `MAX_CONNECTIONS` is a constant that you should define in your program to be the maximum reasonable number of connections.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-37fbb11e-68c3-417a-a79b-6562206fa7af",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflows. This function copies a specified number of characters from one string to another. If the source string is longer than the specified number of characters, `strncpy` does not append a null character to the destination string, which can lead to buffer overflow vulnerabilities.\n\nIn the provided code snippet, `strncpy` is used to copy the string from `argv[1]` to `args.ip_list_file`. If the length of `argv[1]` is greater than the size of `args.ip_list_file`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions such as `strlcpy` or `snprintf` which ensure null-termination of the destination string. Also, always validate the length of the input string before copying it to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf`:\n\n```cpp\n// Using strlcpy\nstrlcpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file));\n\n// Using snprintf\nsnprintf(args.ip_list_file, sizeof(args.ip_list_file), \"%s\", argv[1]);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` or `<string.h>` for `strncpy`, `strlcpy`, or `snprintf` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-3a2e4633-9409-48da-b822-5eaf02b65aef",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee that the destination string will be null-terminated, which can lead to buffer overflow vulnerabilities. In the provided code snippet, `strncpy` is used to copy a string from `targ->conn->peer_ip` to `peer_ip`. If the source string is longer than `INET_ADDRSTRLEN`, the destination string `peer_ip` will not be null-terminated, potentially leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that ensure null-termination of the destination string. In C++, this can be achieved by using `strlcpy` instead of `strncpy`. If `strlcpy` is not available, you can use `snprintf` as an alternative.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf` as shown below:\n\n```cpp\n// Using strlcpy\nstrlcpy(peer_ip, targ->conn->peer_ip, sizeof(peer_ip));\n\n// Using snprintf\nsnprintf(peer_ip, sizeof(peer_ip), \"%s\", targ->conn->peer_ip);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` or `<string.h>` for `strncpy`, `strlcpy`, and `snprintf`\n- `<netinet/in.h>` for `INET_ADDRSTRLEN`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the availability of the links is subject to the respective organizations' policies and may change over time."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-694fe2df-0531-4b7a-8ecc-f6c28f3df658",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 452,
                  "startColumn": 12,
                  "endLine": 452,
                  "endColumn": 124,
                  "charOffset": 17862,
                  "charLength": 112,
                  "snippet": {
                    "text": "strncpy(dev.virtual_intf, devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(), MAX_STR_LEN - 1)",
                    "rendered": {
                      "text": "strncpy(dev.virtual_intf, devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(), MAX_STR_LEN - 1)",
                      "markdown": "`strncpy(dev.virtual_intf, devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(), MAX_STR_LEN - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17862,
                        "charLength": 112
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dev.virtual_intf,  MAX_STR_LEN - 1,  devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17862,
                        "charLength": 112
                      },
                      "insertedContent": {
                        "text": "strlcpy(dev.virtual_intf,  devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(),  MAX_STR_LEN - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-26bfeeca-34da-4263-a83a-d81010d6e916",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 352,
                  "startColumn": 12,
                  "endLine": 352,
                  "endColumn": 96,
                  "charOffset": 14098,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr)",
                    "rendered": {
                      "text": "memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr)",
                      "markdown": "`memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14098,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&planar_intf.ipv4_addr, <size of &planar_intf.ipv4_addr>,  buffer.data() + offset,  sizeof(planar_intf.ipv4_addr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea26081a-a14c-46bd-8863-8797b480e42d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Prohibited strncpy C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 464,
                  "startColumn": 16,
                  "endLine": 464,
                  "endColumn": 116,
                  "charOffset": 18581,
                  "charLength": 100,
                  "snippet": {
                    "text": "strncpy(pi.name, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(), MAX_STR_LEN - 1)",
                    "rendered": {
                      "text": "strncpy(pi.name, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(), MAX_STR_LEN - 1)",
                      "markdown": "`strncpy(pi.name, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(), MAX_STR_LEN - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18581,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pi.name,  MAX_STR_LEN - 1,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18581,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "strlcpy(pi.name,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(),  MAX_STR_LEN - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-41ce96b8-452f-4845-9e2f-4b370d1774be",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 463,
                  "startColumn": 16,
                  "endLine": 463,
                  "endColumn": 112,
                  "charOffset": 18467,
                  "charLength": 96,
                  "snippet": {
                    "text": "strncpy(pi.id, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(), MAX_STR_LEN - 1)",
                    "rendered": {
                      "text": "strncpy(pi.id, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(), MAX_STR_LEN - 1)",
                      "markdown": "`strncpy(pi.id, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(), MAX_STR_LEN - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18467,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pi.id,  MAX_STR_LEN - 1,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18467,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "strlcpy(pi.id,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(),  MAX_STR_LEN - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ed38e1c1-9b42-45fc-8b7e-221c418ee76a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 356,
                  "startColumn": 12,
                  "endLine": 356,
                  "endColumn": 96,
                  "charOffset": 14288,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr)",
                    "rendered": {
                      "text": "memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr)",
                      "markdown": "`memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14288,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&planar_intf.ipv6_addr, <size of &planar_intf.ipv6_addr>,  buffer.data() + offset,  sizeof(planar_intf.ipv6_addr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cd9fb11f-7629-41f0-aab3-6d370d2f5176",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 12,
                  "endLine": 347,
                  "endColumn": 86,
                  "charOffset": 13861,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len)",
                    "rendered": {
                      "text": "memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len)",
                      "markdown": "`memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13861,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(planar_intf.name, <size of planar_intf.name>,  (char*)(buffer.data() + offset),  planar_name_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-93826d68-f5dd-4d22-af2a-5cf82d648bed",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 8,
                  "endLine": 320,
                  "endColumn": 86,
                  "charOffset": 12550,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len)",
                    "rendered": {
                      "text": "memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len)",
                      "markdown": "`memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12550,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(device.virtual_intf, <size of device.virtual_intf>,  (char*)(buffer.data() + offset),  virtual_intf_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-51be2d47-b18d-4b7b-894a-4b1a12dc31e8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 340,
                  "startColumn": 12,
                  "endLine": 340,
                  "endColumn": 82,
                  "charOffset": 13487,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len)",
                    "rendered": {
                      "text": "memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len)",
                      "markdown": "`memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13487,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s(planar_intf.id, <size of planar_intf.id>,  (char*)(buffer.data() + offset),  planar_id_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2577d3cf-2c74-4bd1-bf6c-af1ad621b987",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 325,
                  "startColumn": 8,
                  "endLine": 325,
                  "endColumn": 84,
                  "charOffset": 12769,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip)",
                    "rendered": {
                      "text": "memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip)",
                      "markdown": "`memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12769,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&device.virtual_ip, <size of &device.virtual_ip>,  buffer.data() + offset,  sizeof(device.virtual_ip)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c6b9981a-e8c2-484a-bbec-2e53d7e29db6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 97,
                  "endLine": 266,
                  "endColumn": 121,
                  "charOffset": 10566,
                  "charLength": 24,
                  "snippet": {
                    "text": "strlen(planar_intf.name)",
                    "rendered": {
                      "text": "strlen(planar_intf.name)",
                      "markdown": "`strlen(planar_intf.name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10566,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10566,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eb563567-9858-4f03-b905-199471f683f5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 45,
                  "endLine": 264,
                  "endColumn": 69,
                  "charOffset": 10319,
                  "charLength": 24,
                  "snippet": {
                    "text": "strlen(planar_intf.name)",
                    "rendered": {
                      "text": "strlen(planar_intf.name)",
                      "markdown": "`strlen(planar_intf.name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10319,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10319,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-143c7cd4-1984-4af6-85f8-9ca13300538f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 259,
                  "startColumn": 43,
                  "endLine": 259,
                  "endColumn": 65,
                  "charOffset": 9960,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(planar_intf.id)",
                    "rendered": {
                      "text": "strlen(planar_intf.id)",
                      "markdown": "`strlen(planar_intf.id)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9960,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9960,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a1c8b7c2-82a1-4bf3-a42d-ce047807cffb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 261,
                  "startColumn": 93,
                  "endLine": 261,
                  "endColumn": 115,
                  "charOffset": 10195,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(planar_intf.id)",
                    "rendered": {
                      "text": "strlen(planar_intf.id)",
                      "markdown": "`strlen(planar_intf.id)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10195,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10195,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8705759c-62fb-4b73-9a53-71a282206461",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 246,
                  "startColumn": 99,
                  "endLine": 246,
                  "endColumn": 126,
                  "charOffset": 9339,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(device.virtual_intf)",
                    "rendered": {
                      "text": "strlen(device.virtual_intf)",
                      "markdown": "`strlen(device.virtual_intf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9339,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9339,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-14f78204-8b52-4ca1-b846-0df864c1d867",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 42,
                  "endLine": 244,
                  "endColumn": 69,
                  "charOffset": 9088,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(device.virtual_intf)",
                    "rendered": {
                      "text": "strlen(device.virtual_intf)",
                      "markdown": "`strlen(device.virtual_intf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9088,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9088,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d6d6caf0-4df1-4cf3-a170-12ef1830694f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 62,
                  "endLine": 489,
                  "endColumn": 109,
                  "charOffset": 19714,
                  "charLength": 47,
                  "snippet": {
                    "text": "malloc(total_LNs * sizeof(struct RecvThreadArg)",
                    "rendered": {
                      "text": "malloc(total_LNs * sizeof(struct RecvThreadArg)",
                      "markdown": "`malloc(total_LNs * sizeof(struct RecvThreadArg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19714,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5be2c134-80d0-4604-92cb-d43aa51a95ca",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 488,
                  "startColumn": 37,
                  "endLine": 488,
                  "endColumn": 73,
                  "charOffset": 19613,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(total_LNs * sizeof(pthread_t)",
                    "rendered": {
                      "text": "malloc(total_LNs * sizeof(pthread_t)",
                      "markdown": "`malloc(total_LNs * sizeof(pthread_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19613,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dbc7f200-0be9-49d6-8fee-bd40bbfa37f8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Prohibited strncpy Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 12,
                  "endLine": 470,
                  "endColumn": 74,
                  "charOffset": 18896,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN)",
                    "rendered": {
                      "text": "strncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN)",
                      "markdown": "`strncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18896,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s(connArr[accepted].peer_ip,  INET_ADDRSTRLEN,  \"unknown\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18896,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy(connArr[accepted].peer_ip,  \"unknown\",  INET_ADDRSTRLEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fd8a761c-5c32-47bb-bd69-bae17c3583f6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 454,
                  "startColumn": 53,
                  "endLine": 454,
                  "endColumn": 97,
                  "charOffset": 18164,
                  "charLength": 44,
                  "snippet": {
                    "text": "malloc(total_LNs * sizeof(struct Connection)",
                    "rendered": {
                      "text": "malloc(total_LNs * sizeof(struct Connection)",
                      "markdown": "`malloc(total_LNs * sizeof(struct Connection)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18164,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-37fbb11e-68c3-417a-a79b-6562206fa7af",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 406,
                  "startColumn": 5,
                  "endLine": 406,
                  "endColumn": 67,
                  "charOffset": 16016,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file))",
                    "rendered": {
                      "text": "strncpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file))",
                      "markdown": "`strncpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file))`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16016,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s(args.ip_list_file,  sizeof(args.ip_list_file,  argv[1])"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16016,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy(args.ip_list_file,  argv[1],  sizeof(args.ip_list_file)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3a2e4633-9409-48da-b822-5eaf02b65aef",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 260,
                  "startColumn": 4,
                  "endLine": 260,
                  "endColumn": 58,
                  "charOffset": 10595,
                  "charLength": 54,
                  "snippet": {
                    "text": "strncpy(peer_ip, targ->conn->peer_ip, INET_ADDRSTRLEN)",
                    "rendered": {
                      "text": "strncpy(peer_ip, targ->conn->peer_ip, INET_ADDRSTRLEN)",
                      "markdown": "`strncpy(peer_ip, targ->conn->peer_ip, INET_ADDRSTRLEN)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10595,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strcpy_s(peer_ip,  INET_ADDRSTRLEN,  targ->conn->peer_ip)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10595,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strlcpy(peer_ip,  targ->conn->peer_ip,  INET_ADDRSTRLEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}