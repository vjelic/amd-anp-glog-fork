{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-b97a9e39-861a-415c-bdd8-b3187654478b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee that the destination string will be null-terminated if the source string is longer than the specified length. This can lead to buffer overflow vulnerabilities, which can be exploited to execute arbitrary code, cause a system crash, or expose sensitive information.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using the `std::string` class or the `strlcpy` function if available.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` if available, or use `std::string::copy`:\n\n```cpp\nstd::string src = intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID);\nstd::string dest(MAX_STR_LEN - 1, '\\0');\nsrc.copy(dest.data(), dest.size());\npi.id = dest;\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>` for `std::string`\n- `<map>` for `std::map`\n- `<boost/property_tree/ptree.hpp>` for `boost::property_tree::ptree`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links are valid and active for anonymous users at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-ea9759fa-21a9-4803-b1e3-2393a77d4354",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is a buffer overflow vulnerability that can occur when using the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. If the size of the destination buffer is smaller than the size of the source buffer, it can lead to a buffer overflow. This can overwrite adjacent memory and lead to unexpected behavior, including crashes, data corruption, and potential code execution.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from a buffer into the `ipv6_addr` field of the `planar_intf` structure. If the size of the data in the buffer is larger than the size of `ipv6_addr`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` (in C11), which take the size of the destination buffer as an argument and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code snippet:\n\n```cpp\nif (buffer.size() - offset >= sizeof(planar_intf.ipv6_addr)) {\n    memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we check that the size of the data in the buffer (minus the offset) is not larger than the size of `ipv6_addr` before calling `memcpy`.\n\n## Library Dependencies\n\nThe code snippet requires the following library dependencies:\n\n- `<cstring>`: for the `memcpy` function\n- `<vector>`: if `buffer` is a `std::vector`\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-87e160c1-3b28-4fd1-9fba-45a1d0faa9b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee null-termination of the destination string when the source string length is greater than or equal to the destination buffer size. This can lead to buffer overflows, which can be exploited to execute arbitrary code, overwrite important data, or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, consider using safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using the `std::string` class or the `strlcpy` function if available.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` if available, or use `std::string::copy`:\n\n```cpp\nstd::string virtual_intf = devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE);\nif (virtual_intf.length() >= MAX_STR_LEN) {\n    virtual_intf.resize(MAX_STR_LEN - 1);\n}\nstd::copy(virtual_intf.begin(), virtual_intf.end(), dev.virtual_intf);\ndev.virtual_intf[virtual_intf.size()] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string>` for `std::string`\n- `<algorithm>` for `std::copy`\n- `<boost/property_tree/ptree.hpp>` for `boost::property_tree::ptree::get`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-655d830b-8477-4a21-b2ff-dbd3f1fd9e58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow. This can occur when the source string's length is greater than the destination buffer size. The function does not null-terminate the destination string when the source string's length is greater than or equal to the destination buffer size. This can lead to undefined behavior and potential security vulnerabilities.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that ensure null-termination and prevent buffer overflow. In C++, this can be achieved by using the `std::string` class or the `strlcpy` function if available.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` if available, or use `std::string`:\n\n```cpp\nstd::string name = intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME);\nif (name.length() >= MAX_STR_LEN) {\n    name = name.substr(0, MAX_STR_LEN - 1);\n}\nstrlcpy(pi.name, name.c_str(), MAX_STR_LEN);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `<string>` for `std::string`\n- `<cstring>` for `strlcpy` (if available)\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the availability of `strlcpy` may vary depending on the platform and compiler. If `strlcpy` is not available, consider using a safe string handling library or function that provides similar functionality."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-dcd9eccc-42aa-4fae-9e3d-b6b953ab900f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `memcpy` function in C++. This function is used to copy a block of memory from one location to another. The vulnerability arises when the size of the destination buffer is smaller than the size of the source buffer. This can lead to a buffer overflow, which can cause the program to crash or, in some cases, allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. Additionally, consider using safer alternatives to `memcpy`, such as `strncpy` or `memcpy_s`, which include built-in checks to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nHere is a fixed version of the code:\n\n```cpp\nif (buffer.size() - offset >= sizeof(planar_intf.ipv4_addr)) {\n    memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr));\n} else {\n    // Handle error\n}\n```\n\nIn this version, we first check if the size of the source buffer (minus the offset) is greater than or equal to the size of the destination buffer. If it is, we proceed with the `memcpy`. If not, we handle the error in some way.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e7dd95a6-66f0-47c8-9884-ad459d5252a6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflow condition, which can lead to vulnerabilities if the destination buffer is smaller than the source buffer. In the provided code snippet, if `planar_name_len` is larger than the size of `planar_intf.name`, it can lead to a buffer overflow vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before calling `memcpy`. If the size of the source buffer is larger than the destination buffer, you should either resize the destination buffer or truncate the source data to fit into the destination buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (planar_name_len <= sizeof(planar_intf.name)) {\n    memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len);\n} else {\n    // Handle error condition, e.g., throw an exception or return an error code\n}\n```\n\nIn this fix, we first check if `planar_name_len` is less than or equal to the size of `planar_intf.name`. If it is, we proceed with the `memcpy`. If it is not, we handle the error condition appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>`: This library is required if `buffer` is a `std::vector`.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a86c5718-2b86-47e8-a068-5cf589784fe1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, often exploited by attackers to execute arbitrary code or cause a denial of service.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from a buffer to the `planar_intf.id` variable. If the size of the data in the buffer (defined by `planar_id_len`) is larger than the size of `planar_intf.id`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(planar_intf.id) >= planar_id_len) {\n    memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len);\n} else {\n    // Handle error: destination buffer is too small\n}\n```\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: for the `memcpy` function\n- `<vector>` or `<array>`: if `buffer` is a standard C++ container\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-95ada997-f561-446a-86f2-1c1da4bfb4e9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for any buffer overflows, which can lead to vulnerabilities if the size of the source is larger than the destination. In the provided code snippet, the `memcpy` function is copying data from `buffer.data() + offset` to `device.virtual_ip`. If the size of the data at `buffer.data() + offset` is larger than `device.virtual_ip`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. If the source is larger, you should not proceed with the copy operation.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (sizeof(device.virtual_ip) >= sizeof(buffer.data() + offset)) {\n    memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip));\n} else {\n    // Handle error\n}\n```\n\nIn this updated code, we first check if `device.virtual_ip` is large enough to hold the data at `buffer.data() + offset`. If it is, we proceed with the `memcpy` operation. If not, we handle the error appropriately.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7e577a82-b508-4a22-bbec-f9b1cedcf0bb",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer. This is a common vulnerability in C++ programming that can lead to serious security issues such as data corruption, system crash, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the source data. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\nAdditionally, consider using safer alternatives to `memcpy` such as `strncpy` or `memcpy_s` which include a length parameter to prevent buffer overflow.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the given code:\n\n```cpp\nif (buffer.size() - offset >= virtual_intf_len) {\n    memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len);\n} else {\n    // Handle error: source data is larger than destination buffer\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-771028be-797d-43b7-8c32-555a6e44a2cd",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(planar_intf.name)` with `strnlen(planar_intf.name, sizeof(planar_intf.name))`.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-26783df5-297f-457b-a656-46fa57cdd771",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(planar_intf.name)` with `strnlen(planar_intf.name, sizeof(planar_intf.name))`.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library for the `strlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-c16e4831-efa6-42dd-a4b3-cf59c835a5c3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(planar_intf.id);\n```\n\nUse:\n\n```cpp\nstrnlen(planar_intf.id, sizeof(planar_intf.id));\n```\n\nThis will ensure that `strnlen()` does not read beyond the size of `planar_intf.id`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-186f60f6-97bf-4309-becd-2d3f0f527eec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, use safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\nstrlen(planar_intf.id);\n```\n\nUse:\n\n```cpp\nstrnlen(planar_intf.id, sizeof(planar_intf.id));\n```\n\nThis will ensure that `strnlen()` does not read beyond the size of `planar_intf.id`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-d1033a99-0f8f-48a5-8552-599f8da159b9",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(device.virtual_intf)`, the vulnerability arises if `device.virtual_intf` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(device.virtual_intf)` with `strnlen(device.virtual_intf, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of `device.virtual_intf`.\n\n```cpp\n#include <string.h> // for strnlen\n\n#define MAX_LENGTH 100 // replace with actual maximum length\n\nsize_t length = strnlen(device.virtual_intf, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `strnlen()` function.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-ca0e6428-8222-4951-8b6f-decb6b9671fe",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(device.virtual_intf)`, the vulnerability arises if `device.virtual_intf` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum length of the string.\n\n## Source Code Fix Recommendation\n\nReplace `strlen(device.virtual_intf)` with `strnlen(device.virtual_intf, MAX_LENGTH)`, where `MAX_LENGTH` is the maximum expected length of `device.virtual_intf`.\n\n```cpp\n#include <string.h> // for strnlen\n\n#define MAX_LENGTH 100 // replace with actual maximum length\n\nsize_t length = strnlen(device.virtual_intf, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe code example requires the `<string.h>` library for the `strnlen()` function.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-d6ecb828-7e6f-45a9-abdf-999292ab3e7a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. If the size of the memory to be allocated is controlled by the user or can be influenced by an attacker, it can lead to various security issues such as Denial of Service (DoS), memory corruption, or even remote code execution.\n\nIn the provided code snippet, the size of the memory to be allocated is determined by the variable `total_LNs`. If an attacker can control the value of `total_LNs`, they can cause the program to allocate an excessively large amount of memory, leading to a DoS condition. Alternatively, they could cause the program to allocate too little memory, which could lead to buffer overflow conditions if the program later tries to store more data in the allocated space than it can hold.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the size of the memory to be allocated is not controllable by an attacker. You should validate and sanitize all input, and use safe functions that limit the size of the memory allocation.\n\n## Source Code Fix Recommendation\n\n```cpp\nsize_t total_LNs = get_total_LNs(); // get the value from a trusted source\nif (total_LNs > MAX_LNs) { // MAX_LNs is a predefined constant\n    // handle the error, e.g., by terminating the program\n    fprintf(stderr, \"Error: too many LNs\\n\");\n    exit(1);\n}\npthread_t* threads = (pthread_t*) malloc(total_LNs * sizeof(pthread_t));\nif (threads == NULL) {\n    // handle the error, e.g., by terminating the program\n    fprintf(stderr, \"Error: could not allocate memory\\n\");\n    exit(1);\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `pthread.h`: for the `pthread_t` type\n- `stdlib.h`: for the `malloc` function\n- `stdio.h`: for the `fprintf` and `stderr` functions\n\n## References\n\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-81523ecc-87f1-4b4d-a75a-4f55bf34ba01",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. If the size of the memory to be allocated is controlled by the user or can be influenced by an attacker, it can lead to various security issues such as Denial of Service (DoS), Remote Code Execution (RCE), or Information Disclosure.\n\nIn the provided code snippet, the size of the memory to be allocated is determined by the `total_LNs` variable. If an attacker can control or influence this value, they could cause the program to allocate too much memory, leading to a DoS condition. Alternatively, they could cause the program to allocate too little memory, which could lead to a buffer overflow if the program then tries to store more data in the allocated memory than it can hold.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the size of the memory to be allocated is not controllable by an attacker. You should also ensure that you check the return value of `malloc` to make sure that the memory allocation was successful. If `malloc` fails, it returns a null pointer, and any attempt to use this pointer will result in undefined behavior.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (total_LNs > MAX_ALLOWED_LNS) {\n    // Handle error condition\n    return;\n}\n\nstruct RecvThreadArg *args = (struct RecvThreadArg *) malloc(total_LNs * sizeof(struct RecvThreadArg));\nif (args == NULL) {\n    // Handle error condition\n    return;\n}\n```\n\nIn this fixed code, we first check if `total_LNs` is greater than a predefined maximum allowed value (`MAX_ALLOWED_LNS`). If it is, we handle the error condition and return. After calling `malloc`, we check if the returned pointer is null, indicating that the memory allocation failed. If it is, we handle the error condition and return.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP Resources\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-7f1decfd-9313-45f9-aae3-c6a7b7105c3a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe and can lead to vulnerabilities such as buffer overflow. This is because `strncpy` does not guarantee a null-terminated string if the source string length is greater than or equal to the destination buffer size. This can lead to undefined behavior or crashes when the string is used.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that guarantee null-termination, such as `strlcpy` or `snprintf`. If these are not available, you should manually ensure null-termination of the string.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf`:\n\n```cpp\n// Using strlcpy\nstrlcpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN);\n\n// Using snprintf\nsnprintf(connArr[accepted].peer_ip, INET_ADDRSTRLEN, \"%s\", \"unknown\");\n```\n\nIf these functions are not available, manually ensure null-termination:\n\n```cpp\nstrncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN - 1);\nconnArr[accepted].peer_ip[INET_ADDRSTRLEN - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<string.h>` or `<cstring>` for `strncpy`, `strlcpy`, or `snprintf`\n- `<netinet/in.h>` for `INET_ADDRSTRLEN`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the availability of the links is subject to the respective organizations' policies and may change over time."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-f4ce486f-391e-406d-bf62-9d6118ec11b3",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe vulnerability in question is related to the `malloc` function in C++. This function is used to allocate a block of memory dynamically. If the size of the memory to be allocated is controlled by the user or can be influenced by an attacker, it can lead to various security issues such as Denial of Service (DoS), memory corruption, or even remote code execution.\n\nIn the provided code snippet, the size of the memory to be allocated is determined by the `total_LNs` variable. If an attacker can control or influence this value, they could cause the program to allocate an excessively large amount of memory, leading to a DoS condition. Alternatively, they could cause the program to allocate too little memory, which could lead to memory corruption if the program later tries to write more data to the allocated block than it can hold.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Validate and sanitize all user inputs: Never trust user input blindly. Always validate it to ensure it is within the expected range. In this case, you should check that the value of `total_LNs` is within a reasonable range before using it to allocate memory.\n\n2. Use functions that limit the amount of memory that can be allocated: Instead of `malloc`, consider using functions like `calloc`, which takes two arguments: the number of elements and the size of each element. This can help prevent excessively large memory allocations.\n\n3. Handle `malloc` failures: Always check if `malloc` returns `NULL`, which indicates that the memory allocation failed. If `malloc` fails, make sure to handle this error gracefully.\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nif (total_LNs > MAX_CONNECTIONS) {\n    // Handle error: total_LNs is too large\n} else {\n    struct Connection* connections = (struct Connection*) malloc(total_LNs * sizeof(struct Connection));\n    if (connections == NULL) {\n        // Handle error: malloc failed\n    } else {\n        // Continue with program\n    }\n}\n```\n\nIn this code, `MAX_CONNECTIONS` is a constant that you should define in your program to be the maximum reasonable number of connections.\n\n## Library Dependencies\n\nThe provided code snippet does not appear to have any library dependencies beyond the standard C++ libraries.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)\n\nPlease note that these links are subject to change and may not always be accessible."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-4c9243c7-f02c-420e-bb64-dd51715501c8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflows. This function copies a specified number of characters from one string to another. If the source string is longer than the specified number of characters, `strncpy` does not append a null character to the destination string, which can lead to buffer overflow vulnerabilities.\n\nIn the provided code snippet, `strncpy` is used to copy the string from `argv[1]` to `args.ip_list_file`. If the length of `argv[1]` is greater than the size of `args.ip_list_file`, it can lead to a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions such as `strlcpy` or `snprintf` which ensure null-termination of the destination string. Also, always validate the length of the input string before copying it to prevent buffer overflows.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf`:\n\n```cpp\n// Using strlcpy\nstrlcpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file));\n\n// Using snprintf\nsnprintf(args.ip_list_file, sizeof(args.ip_list_file), \"%s\", argv[1]);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` or `<string.h>` for `strncpy`, `strlcpy`, or `snprintf` functions.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-f7348707-97be-4f68-ba82-f56bdba2a44f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string. However, it is considered unsafe because it does not check the size of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can lead to arbitrary code execution, denial of service, or information disclosure vulnerabilities.\n\nIn the provided code snippet, `strcpy(root_ip, ip_list[i])`, the `strcpy` function is used to copy the string from `ip_list[i]` to `root_ip`. If `ip_list[i]` is larger than `root_ip`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string copy functions that check the size of the destination buffer. In C++, this can be done using the `strncpy` function, which takes an additional parameter specifying the maximum number of characters to be copied.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function:\n\n```cpp\nstrncpy(root_ip, ip_list[i], sizeof(root_ip));\nroot_ip[sizeof(root_ip) - 1] = '\\0'; // Ensure null termination\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-8f6d58df-f445-4270-a6de-411bc549333a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strcpy` function in C++ is a standard library function that copies a string from source to destination. It is considered unsafe because it does not check the array bounds of the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer.\n\nThis vulnerability is known as \"Detected Use of Prohibited C Function (strcpy)\" and it can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that include a length parameter. This parameter is used to specify the maximum number of characters to be copied from the source string, which prevents buffer overflow.\n\nIn C++, you can use the `strncpy` function, which includes a length parameter. However, `strncpy` does not null-terminate the destination string if the source string is longer than the specified length. Therefore, you should manually add a null character at the end of the destination string.\n\nAnother safer alternative is the `strlcpy` function, which always null-terminates the destination string. However, `strlcpy` is not a standard C++ function and may not be available on all platforms.\n\n## Source Code Fix Recommendation\n\nReplace the `strcpy` function with the `strncpy` function and manually add a null character at the end of the destination string:\n\n```cpp\nstrncpy(root_ip, ip_list[0], sizeof(root_ip) - 1);\nroot_ip[sizeof(root_ip) - 1] = '\\0';\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links are valid and active for anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-fc8644ae-f127-400f-98e6-790ae2b42ee4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee that the destination string will be null-terminated, which can lead to buffer overflow vulnerabilities. In the provided code snippet, `strncpy` is used to copy a string from `targ->conn->peer_ip` to `peer_ip`. If the source string is longer than `INET_ADDRSTRLEN`, the destination string `peer_ip` will not be null-terminated, potentially leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string copy functions that ensure null-termination of the destination string. In C++, this can be achieved by using `strlcpy` instead of `strncpy`. If `strlcpy` is not available, you can use `snprintf` as an alternative.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf` as shown below:\n\n```cpp\n// Using strlcpy\nstrlcpy(peer_ip, targ->conn->peer_ip, sizeof(peer_ip));\n\n// Using snprintf\nsnprintf(peer_ip, sizeof(peer_ip), \"%s\", targ->conn->peer_ip);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>` or `<string.h>` for `strncpy`, `strlcpy`, and `snprintf`\n- `<netinet/in.h>` for `INET_ADDRSTRLEN`\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the availability of the links is subject to the respective organizations' policies and may change over time."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-15760377-ed16-484d-b98f-96dc7eb9884b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow errors. This function copies a specified number of characters from one string to another. If the source string is longer than the specified number of characters, `strncpy` does not append a null character to the destination string. This can lead to buffer overflow if the destination string is used in a context that expects it to be null-terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, consider using safer string handling functions that ensure null-termination, such as `strlcpy` (BSD) or `strncpy_s` (Microsoft). If these are not available, you can manually append a null character to the destination string after copying.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nstrncpy(local_ip, addr_str, INET_ADDRSTRLEN - 1);\nlocal_ip[INET_ADDRSTRLEN - 1] = '\\0';\n```\n\nThis code ensures that `local_ip` is always null-terminated, preventing potential buffer overflow.\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `#include <cstring>` for `strncpy`\n- `#include <arpa/inet.h>` for `INET_ADDRSTRLEN`\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-676: Use of Potentially Dangerous Function](https://cwe.mitre.org/data/definitions/676.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-1cb63f91-894d-4329-b1cc-cfb8c9f3f748",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(ip_list[count])`, there is a potential vulnerability if `ip_list[count]` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Be careful when manipulating strings, and consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nsize_t len;\nif (ip_list[count] != NULL) {\n    len = strnlen(ip_list[count], MAX_LENGTH);\n} else {\n    // Handle error\n}\n```\n\nIn this code, `MAX_LENGTH` is the maximum expected length of the string. If `ip_list[count]` is longer than `MAX_LENGTH`, `strnlen()` will stop reading and return `MAX_LENGTH`.\n\n## Library Dependencies\n\nThe `strlen()` and `strnlen()` functions are part of the C standard library (`<cstring>` in C++, `<string.h>` in C), so this library is required for the code to execute properly.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-7c84ab4b-edda-4fdc-9cc4-4977fe4619cc",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-fd809644-9ef2-4794-b159-56bf2b0ea79c",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-0f727ccc-4bbe-4e58-9180-b7bc7089de78",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-3512e1c0-48af-4373-809f-437f345b1066",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-b7db5c18-1117-4168-ad5c-26f2db80d52b",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-8b284847-06f7-4c1b-9a97-01af54c5820a",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-b6d4946a-4d20-4017-a2a2-32aeab8d42ea",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. If the size argument passed to `malloc` is not properly validated or calculated, it can lead to buffer overflows, integer overflows, or other memory corruption issues. This can potentially allow an attacker to execute arbitrary code or cause a Denial of Service (DoS) condition.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate and properly calculate the size argument passed to `malloc`. Avoid using user-supplied or untrusted data directly as the size argument. Also, always check the return value of `malloc` to ensure that the memory allocation was successful before using the returned pointer.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the code:\n\n```c++\nstruct ncclIbMrHandle* handle = (struct ncclIbMrHandle*) malloc(sizeof(struct ncclIbMrHandle));\nif (handle == NULL) {\n    // Handle malloc failure (e.g., by returning or throwing an error)\n}\n// Continue with your code\n```\n\nIn this code, we first allocate memory using `malloc` and then check if the returned pointer is `NULL`. If `malloc` fails, it returns `NULL` and we handle this case appropriately.\n\n## Library Dependencies\n\nThe code example does not require any specific library dependencies other than the standard C library, which provides the `malloc` function.\n\n## OWASP Resources\n\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)\n- [CWE-789: Uncontrolled Memory Allocation](https://cwe.mitre.org/data/definitions/789.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-aa38016f-4c8f-4342-8819-693321a7f18e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, consider using safer functions that include size checks, such as `strncpy` or `memcpy_s` (in C11).\n\n## Source Code Fix Recommendation\n\nHere is a possible fix for the provided code snippet:\n\n```cpp\nstruct ncclIbConnectionMetadata meta;\n// Ensure stage->buffer is large enough\nif (sizeof(stage->buffer) >= sizeof(meta)) {\n    memcpy(stage->buffer, &meta, sizeof(meta));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe code example provided requires the following library dependencies:\n\n- `string.h`: This library is required for the `memcpy` function.\n- `nccl.h`: This library is required for the `ncclIbConnectionMetadata` struct.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n## Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-d49f1007-5643-4757-8fa5-f04c970442c4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee that a null character will be appended at the end of the destination string. This can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer. This is because `strncpy` will copy characters from the source string to the destination buffer until it has copied the specified number of characters, even if the source string is longer than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use safer string copy functions that guarantee null-termination of the destination string. In C++, this can be achieved by using the `strlcpy` function, which is designed to be safer, more consistent, and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with the `strlcpy` function:\n\n```cpp\nstrlcpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME);\n```\n\n## Library Dependencies\n\nThe `strlcpy` function is not a standard C++ function, but it is available on most Unix-like systems, including Linux and BSD. If you are using a system where `strlcpy` is not available, you may need to implement it yourself or use a third-party library that provides it.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-0b4bd6b8-9e85-4cf2-b30e-48df38060f58",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `stage->buffer` to `&remMeta`. If the size of `stage->buffer` is larger than `sizeof(struct ncclIbConnectionMetadata)`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before using `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function like `memcpy_s`:\n\n```cpp\nmemcpy_s(&remMeta, sizeof(struct ncclIbConnectionMetadata), stage->buffer, sizeof(struct ncclIbConnectionMetadata));\n```\n\n## Library Dependencies\n\nThe provided code snippet seems to be using the NCCL library for multi-GPU and multi-node collective communication primitives. Therefore, the NCCL library is required for this code to execute properly.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0d2246c8-e19d-436c-84c3-2954f7b0b5e0",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, the `memcpy` function is used to copy data from `stage->buffer` to `remMeta`. If the size of `stage->buffer` is larger than `remMeta`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\nAdditionally, consider using safer functions that include buffer size checks, such as `strncpy` or `memcpy_s` (in C11), instead of `memcpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with a safer function that includes buffer size checks. For example:\n\n```cpp\nif(sizeof(remMeta) >= sizeof(stage->buffer)) {\n    memcpy(&remMeta, stage->buffer, sizeof(ncclIbConnectionMetadata));\n} else {\n    // Handle error\n}\n```\n\nOr, using `memcpy_s`:\n\n```cpp\nmemcpy_s(&remMeta, sizeof(remMeta), stage->buffer, sizeof(ncclIbConnectionMetadata));\n```\n\n## Library Dependencies\n\nThe provided code snippet does not provide enough context to determine all library dependencies. However, the `memcpy` function is part of the C standard library, so the code will at least require:\n\n- `<cstring>` or `<string.h>` for `memcpy`\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c1c85b6c-c9b0-43c1-89f6-3ff9db4ed540",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as code execution, denial of service, or information disclosure.\n\nIn the provided code snippet, `memcpy(stage->buffer, &meta, sizeof(meta))`, the `memcpy` function is copying the size of `meta` into `stage->buffer`. If the size of `meta` is larger than `stage->buffer`, it can cause a buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nA safer alternative to `memcpy` is `strncpy`, which allows you to specify the maximum number of bytes to be copied. Here's how you can modify the code:\n\n```cpp\nif(sizeof(meta) <= sizeof(stage->buffer)) {\n    memcpy(stage->buffer, &meta, sizeof(meta));\n} else {\n    // Handle error\n}\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so you need to include the `cstring` header:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c4641aaa-58a6-469d-927a-cc3785df227c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee that a null character will be appended at the end of the destination string. This can lead to buffer overflow vulnerabilities if the source string is longer than the destination buffer. This is because `strncpy` will copy characters from the source string to the destination buffer until it has copied the specified number of characters, even if the source string is longer than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should use safer string copy functions that guarantee null-termination of the destination string. In C++, this can be achieved by using the `strlcpy` function, which is designed to be safer, more consistent, and less error-prone.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with the `strlcpy` function:\n\n```cpp\nstrlcpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME);\n```\n\n## Library Dependencies\n\nThe `strlcpy` function is not a standard C++ function, but it is available on most Unix-like systems, including Linux and BSD. If you are using a system where `strlcpy` is not available, you may need to implement it yourself or use a third-party library that provides it.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-694fa5a1-f535-4a28-b373-c098caa3d5ac",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-0c9f43c1-d7d1-4bf4-938e-fe68123d8ccf",
              "help": {
                "text": "",
                "markdown": "## Description\n\n\"Insecure Cipher Mode Utilized\" vulnerability refers to the use of weak or insecure cryptographic algorithms or modes in a C++ program. This can lead to various security issues, such as data exposure, unauthorized access, or even data manipulation. The vulnerability sink in this case is the Cipher Text Stealing (CTS) mode, which can be insecure if not properly implemented or used in an insecure context.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use secure and up-to-date cryptographic algorithms and modes. Avoid using deprecated or weak cryptographic algorithms. Always use cryptographic modes that provide confidentiality and integrity. It is also important to use cryptographic libraries that are widely accepted and maintained by the community.\n\n## Source Code Fix Recommendation\n\nWithout a specific code example, it's hard to provide a precise fix. However, here's a general recommendation:\n\nIf you're using a library like OpenSSL, instead of using an insecure mode like CTS, you could use a more secure mode like GCM (Galois/Counter Mode). Here's an example of how to set the cipher mode to GCM:\n\n```cpp\nEVP_CIPHER_CTX *ctx;\nint outlen, tmplen;\nunsigned char outbuf[1024];\nEVP_CIPHER_CTX_init(ctx);\nEVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL);\n```\n\n## Library Dependencies\n\nThe library dependencies required by the code example would be:\n\n- OpenSSL\n\n## OWASP and CWE Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS187371"
                ]
              }
            },
            {
              "id": "glog-b3bf4982-9007-4b5b-afeb-d5afc4015c6d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-5f78e82b-ac5c-46a3-a9bd-d682d8bfcc16",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-fd58669b-ad3e-4ce8-bb50-5cd91cae90a3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-93578393-2ffc-4b0c-92fb-976443a837cb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-15e6c2a6-54fb-44cc-a20c-11fc51eb765e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-2a913c38-4d2a-485e-bb1a-7eb94800045f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-5a3d40c4-f7c5-4515-8264-a467dff9c7dd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-c1d98ea8-2b92-4988-b2b8-027681915f41",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-5ad8211d-31f1-40bf-bc1c-fd954e22da0b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior. This is a common vulnerability in C and C++ programming.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives that take the size of the buffer as an argument, such as `strnlen()`, which will not read past the specified length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nReplace the `strlen()` function with `strnlen()`. The `strnlen()` function takes two arguments: the string and the maximum number of characters to read. This can prevent buffer overflows if the string is not null-terminated.\n\n```cpp\nstrnlen(ncclIbMergedDevs[mergedDev].devName, sizeof(ncclIbMergedDevs[mergedDev].devName))\n```\n\n## Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `cstring` or `string.h` for `strlen()` or `strnlen()` function.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-4579055c-9f2b-4470-b14b-252ffdeb816c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function is a part of the C standard library that copies a string, including the null byte ('\\0'), from a source to a destination. The function can lead to a Detected Prohibited C Function (strncpy) vulnerability in C++ programming language. This vulnerability occurs when the function is used improperly, leading to buffer overflow attacks. If the source string length is greater than the destination buffer size, it can lead to memory corruption, causing undefined behavior or even allowing an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, it is recommended to use safer string handling functions that include explicit length checks and null termination. Functions such as `strlcpy` or `strncpy_s` are safer alternatives. Also, always ensure that the destination buffer is large enough to hold the source string including the null byte.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `strncpy_s` function. Here is the fixed code:\n\n```cpp\nstrlcpy(ncclIbMergedDevs[mergedDev].devName, ncclIbDevs[ncclNIbDevs].devName, MAXNAMESIZE);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `cstring` or `string.h` for `strncpy` or `strlcpy` function.\n- `ncclIbMergedDevs` and `ncclIbDevs` are likely part of a custom library specific to the application.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-dbe91414-ed64-4503-95a3-cb02e8162f85",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee null-termination of the destination string when the source string length is greater than or equal to the destination buffer size. This can lead to buffer overflows, which can be exploited to execute arbitrary code, overwrite data, or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using `std::string` or `std::strncpy_s` (in C11) instead of `strncpy`.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `std::strncpy_s` or use `std::string`. Here is an example of how to do it:\n\n```cpp\nstd::strncpy_s(ncclIbDevs[ncclNIbDevs].devName, sizeof(ncclIbDevs[ncclNIbDevs].devName), devices[d]->name, _TRUNCATE);\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `cstring` or `string` (for `strncpy` or `strncpy_s` respectively)\n- `nccl` (for `ncclIbDevs`)\n\n## References\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-0817b320-d21e-4f3c-b18b-310c7bae51bf",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow errors. This function copies a specified number of characters from one string to another. If the source string is longer than the specified number of characters, `strncpy` does not append a null character to the destination string, which can lead to buffer overflow.\n\nBuffer overflow vulnerabilities can lead to various security issues, including denial of service, information disclosure, or even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, consider using safer string handling functions that ensure null-termination and prevent buffer overflow. Functions such as `strlcpy` or `snprintf` can be used as safer alternatives.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or `snprintf`:\n\n```cpp\n// Using strlcpy\nstrlcpy(libPathInfo, \"Unknown\", sizeof(libPathInfo));\n\n// Using snprintf\nsnprintf(libPathInfo, sizeof(libPathInfo), \"%s\", \"Unknown\");\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n```cpp\n#include <string.h>\n```\n\nFor `strlcpy`, you may need to include:\n\n```cpp\n#include <bsd/string.h>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the availability of `strlcpy` may depend on your platform and it is not a standard C library function. Always ensure to check the documentation and availability of functions for your specific development environment."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-57fea9f0-857d-4864-aa03-697fa9e441ae",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(p)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Also, consider using safer alternatives to `strlen(p)`, such as `strnlen(p, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint len = strlen(p);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint max_len = sizeof(p) / sizeof(p[0]);\nint len = strnlen(p, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-7943bc2e-0159-42a6-95ea-df6af21dd5d6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee null-termination of the destination string when the source string length is greater than or equal to the destination buffer size. This can lead to buffer overflows, which can be exploited to execute arbitrary code, overwrite data or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that ensure null-termination of the destination string. In C++, this can be achieved by using the `std::string` class or the `strlcpy` function if available. Always ensure that the destination buffer is large enough to hold the source string including the null-terminator.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strlcpy` or use `std::string`. Here is an example of how to do it with `std::string`:\n\n```cpp\n#include <string>\n\nstd::string libPathInfo = pathInfo.dli_fname;\n```\n\n## Library Dependencies\n\nThe code example requires the following libraries:\n\n- `string` (for `std::string`)\n\n## References\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nPlease note that all links were active and accessible at the time of writing."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e4eeca0c-b583-49c2-af14-a8cb9ec40124",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow errors. This function copies a specified number of characters from one string to another. If the source string is longer than the specified number of characters, `strncpy` does not append a null character to the destination string. This can lead to buffer overflow if the destination string is used in a context that expects it to be null-terminated.\n\nIn the provided code snippet, `strncpy(root_host, processor_name, MPI_MAX_PROCESSOR_NAME)`, if `processor_name` is longer than `MPI_MAX_PROCESSOR_NAME`, `root_host` will not be null-terminated, potentially leading to buffer overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should ensure that the destination string is always null-terminated. This can be achieved by manually appending a null character at the end of the destination string. Additionally, you should always check the length of the source string and ensure it does not exceed the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nstrncpy(root_host, processor_name, MPI_MAX_PROCESSOR_NAME - 1);\nroot_host[MPI_MAX_PROCESSOR_NAME - 1] = '\\0';\n```\n\nIn this fix, we copy one less character than the size of the destination buffer, and then manually append a null character at the end.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `cstring` for the `strncpy` function\n- `mpi.h` for the `MPI_MAX_PROCESSOR_NAME` constant\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the provided links are active and accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-ea031500-8bd1-4a18-b7ab-d1275e72d06e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is a common source of vulnerabilities due to its potential to cause buffer overflow errors. This function copies a specified number of characters from one string to another. If the source string is longer than the specified number of characters, `strncpy` does not append a null character to the destination string. This can lead to buffer overflow if the destination string is used in a context that expects it to be null-terminated.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, consider using safer string handling functions that ensure null-termination and prevent buffer overflow. In C++, this could be achieved by using `std::string` or `std::strncpy_s` (in C11 or later).\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with `strncpy_s`:\n\n```cpp\nstrncpy_s(args.root_ip, sizeof(args.root_ip), root_ip, _TRUNCATE);\n```\n\n## Library Dependencies\n\nThe code example requires the following library dependencies:\n\n- `<cstring>`: for `strncpy` function\n- `<arpa/inet.h>`: for `INET_ADDRSTRLEN` constant\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e7227d69-58be-47df-82ac-e131559a6fd6",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(p)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Also, consider using safer alternatives to `strlen(p)`, such as `strnlen(p, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint len = strlen(p);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint max_len = sizeof(p) / sizeof(p[0]);\nint len = strnlen(p, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-c540852e-91df-440e-9b8d-c8393e422128",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(p)` function in C++ is used to calculate the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string up to, but not including, the terminating null character. If the string does not have a null character, `strlen(p)` will continue reading memory until it encounters a null byte, which can lead to buffer overflows, memory corruption, and other unexpected behavior.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character or by manually adding a null character at the end of your strings. Also, consider using safer alternatives to `strlen(p)`, such as `strnlen(p, max_len)`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null byte.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint len = strlen(p);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar p[] = \"Hello, World!\";\nint max_len = sizeof(p) / sizeof(p[0]);\nint len = strnlen(p, max_len);\n```\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-16cb23c0-0fb6-404d-b3f2-4b9e0f5edeaa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows or information leaks.\n\nIn the provided code snippet, `strlen(\"RoCE v2\")`, there is no direct vulnerability as the string is a string literal which is automatically null-terminated by the compiler. However, if the string was user input or read from an untrusted source, it could potentially not be null-terminated and lead to a vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are properly null-terminated before passing them to `strlen`. If the string is user input or from an untrusted source, consider using safer alternatives such as `strnlen`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, no fix is necessary as the string is a string literal and automatically null-terminated. However, if the string was user input or from an untrusted source, a safer alternative such as `strnlen` could be used:\n\n```cpp\nconst char* str = /* untrusted input */;\nsize_t len = strnlen(str, MAX_LENGTH);\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library (`<cstring>` in C++), so no additional library dependencies are required.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-1e120aff-c367-4123-9038-95f839fc8caa",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(\"RoCE v1\")`, there is no direct vulnerability as the string is a string literal which is automatically null-terminated by the compiler. However, if the string was user input or came from an untrusted source, it could potentially be a source of vulnerability.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are properly null-terminated before passing them to `strlen`. Avoid using `strlen` on strings from untrusted sources. If you must use `strlen` on such strings, ensure that they are properly sanitized and null-terminated.\n\n## Source Code Fix Recommendation\n\nIn the provided code snippet, there is no direct vulnerability. However, if the string was user input or came from an untrusted source, it could be fixed as follows:\n\n```cpp\n#include <cstring>\n\nchar user_input[100];\n// ... (code to get user input)\nuser_input[sizeof(user_input) - 1] = '\\0';\nsize_t length = strlen(user_input);\n```\n\nIn this code, we ensure that the string is null-terminated before passing it to `strlen`.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so the only library dependency required by the code example is:\n\n```cpp\n#include <cstring>\n```\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a30b7957-b057-449f-b664-02c0da738756",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not properly null-terminated, `strlen` will continue reading memory beyond the intended boundary, leading to a buffer overflow vulnerability. This can lead to crashes, incorrect behavior, or even code execution if an attacker can control the overflow.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are properly null-terminated. Avoid using `strlen` on strings that may not be null-terminated. If you are dealing with strings that may not be null-terminated, consider using functions that take a length parameter, such as `strnlen`, which will not read beyond a specified length.\n\n## Source Code Fix Recommendation\n\nIn the specific case of `strlen(\"IB/RoCE v1\")`, the string is a string literal and is automatically null-terminated, so there is no vulnerability. However, if the string were not a literal and its null-termination were not guaranteed, you could use `strnlen` instead:\n\n```cpp\nconst char* str = /* some string that may not be null-terminated */;\nsize_t len = strnlen(str, MAX_LENGTH);\n```\n\nHere, `MAX_LENGTH` is the maximum length you expect `str` to be. `strnlen` will not read beyond this length, preventing a buffer overflow.\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-3759f893-b86a-4628-a0d9-eb68dbbf670b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, which can lead to buffer overflows, memory corruption, and other undefined behavior.\n\nIn the provided code snippet, `strlen(gidRoceVerStr)`, there is a potential vulnerability if `gidRoceVerStr` is not a null-terminated string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives to `strlen()`, such as `strnlen()`, which takes a maximum length parameter and will not read past this length, even if it does not encounter a null character.\n\n## Source Code Fix Recommendation\n\nIf `gidRoceVerStr` is a character array, ensure it is null-terminated:\n\n```cpp\nchar gidRoceVerStr[MAX_LENGTH] = {0}; // initialize all elements to '\\0'\n// populate gidRoceVerStr\nsize_t length = strlen(gidRoceVerStr);\n```\n\nIf `gidRoceVerStr` is a pointer, consider using `strnlen()`:\n\n```cpp\nchar* gidRoceVerStr;\n// allocate and populate gidRoceVerStr\nsize_t length = strnlen(gidRoceVerStr, MAX_LENGTH);\n```\n\nIn both cases, replace `MAX_LENGTH` with the maximum expected length of `gidRoceVerStr`.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so the code requires the `<cstring>` (or `<string.h>` in C) header file.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-20958ea5-3839-4381-9b00-1ccefc8c1c1b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used on a string that is not null-terminated. This can lead to undefined behavior, including reading beyond the buffer's allocated memory, which can cause a program crash or expose sensitive data. This issue is often categorized under buffer over-read vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Ensure Null-Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Input Validation**: Validate and sanitize all inputs to ensure they conform to expected formats and lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer over-read vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nIf you have a code snippet like this:\n\n```cpp\n#include <cstring>\n\nvoid processEnvironmentVariable(const char* env) {\n    size_t length = strlen(env);\n    // Further processing...\n}\n```\n\nYou can mitigate the vulnerability by ensuring the input is null-terminated and using `std::string`:\n\n```cpp\n#include <string>\n#include <iostream>\n\nvoid processEnvironmentVariable(const char* env) {\n    if (env == nullptr) {\n        std::cerr << \"Environment variable is null.\" << std::endl;\n        return;\n    }\n    \n    std::string envStr(env);\n    size_t length = envStr.length();\n    // Further processing...\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the original `strlen` function.\n- `<string>`: For using `std::string`.\n- `<iostream>`: For input/output operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-08890470-54ca-4576-80f3-d21c3aa6183a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used on a string that is not null-terminated. This can lead to undefined behavior, including reading beyond the buffer's allocated memory, which can cause a program crash or expose sensitive data. This issue is often categorized under buffer over-read vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Ensure Null-Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Input Validation**: Validate and sanitize all inputs to ensure they conform to expected formats and lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer over-read vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nIf you have a code snippet like this:\n\n```cpp\n#include <cstring>\n\nvoid processEnvironmentVariable(const char* env) {\n    size_t length = strlen(env);\n    // Further processing...\n}\n```\n\nYou can mitigate the vulnerability by ensuring the input is null-terminated and using `std::string`:\n\n```cpp\n#include <string>\n#include <iostream>\n\nvoid processEnvironmentVariable(const char* env) {\n    if (env == nullptr) {\n        std::cerr << \"Environment variable is null.\" << std::endl;\n        return;\n    }\n    \n    std::string envStr(env);\n    size_t length = envStr.length();\n    // Further processing...\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For the original `strlen` function.\n- `<string>`: For using `std::string`.\n- `<iostream>`: For input/output operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-dc4893f5-b3c2-425d-8b88-506bdc7bd7be",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(str)` function in C++ is used to find the length of a string. The vulnerability arises when the string `str` is not null-terminated, which can lead to buffer overflows, memory corruption, and other unexpected behaviors. This is because `strlen(str)` counts characters until it encounters a null character (`\\0`), and if it doesn't find one, it could continue reading and returning data from memory beyond the intended boundary of the string.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your strings after they have been modified.\n\nAlso, consider using safer alternatives to `strlen(str)`, such as `strnlen(str, max_len)`, which takes a maximum length parameter and will not read beyond this limit, even if it doesn't encounter a null character.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nsize_t len = strlen(str);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nchar str[] = \"Hello, World!\";\nsize_t max_len = sizeof(str) / sizeof(str[0]) - 1;\nsize_t len = strnlen(str, max_len);\n```\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the `<cstring>` library in C++.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_v2.pdf)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-b97a9e39-861a-415c-bdd8-b3187654478b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 463,
                  "startColumn": 16,
                  "endLine": 463,
                  "endColumn": 112,
                  "charOffset": 18467,
                  "charLength": 96,
                  "snippet": {
                    "text": "strncpy(pi.id, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(), MAX_STR_LEN - 1)",
                    "rendered": {
                      "text": "strncpy(pi.id, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(), MAX_STR_LEN - 1)",
                      "markdown": "`strncpy(pi.id, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(), MAX_STR_LEN - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18467,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pi.id,  MAX_STR_LEN - 1,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18467,
                        "charLength": 96
                      },
                      "insertedContent": {
                        "text": "strlcpy(pi.id,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_ID).c_str(),  MAX_STR_LEN - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea9759fa-21a9-4803-b1e3-2393a77d4354",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 356,
                  "startColumn": 12,
                  "endLine": 356,
                  "endColumn": 96,
                  "charOffset": 14288,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr)",
                    "rendered": {
                      "text": "memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr)",
                      "markdown": "`memcpy(&planar_intf.ipv6_addr, buffer.data() + offset, sizeof(planar_intf.ipv6_addr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14288,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&planar_intf.ipv6_addr, <size of &planar_intf.ipv6_addr>,  buffer.data() + offset,  sizeof(planar_intf.ipv6_addr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-87e160c1-3b28-4fd1-9fba-45a1d0faa9b9",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 452,
                  "startColumn": 12,
                  "endLine": 452,
                  "endColumn": 124,
                  "charOffset": 17862,
                  "charLength": 112,
                  "snippet": {
                    "text": "strncpy(dev.virtual_intf, devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(), MAX_STR_LEN - 1)",
                    "rendered": {
                      "text": "strncpy(dev.virtual_intf, devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(), MAX_STR_LEN - 1)",
                      "markdown": "`strncpy(dev.virtual_intf, devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(), MAX_STR_LEN - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17862,
                        "charLength": 112
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dev.virtual_intf,  MAX_STR_LEN - 1,  devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17862,
                        "charLength": 112
                      },
                      "insertedContent": {
                        "text": "strlcpy(dev.virtual_intf,  devices_node.second.get<std::string>(JKEY_VIRTUAL_INTERFACE).c_str(),  MAX_STR_LEN - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-655d830b-8477-4a21-b2ff-dbd3f1fd9e58",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Prohibited strncpy C Function Identified\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 464,
                  "startColumn": 16,
                  "endLine": 464,
                  "endColumn": 116,
                  "charOffset": 18581,
                  "charLength": 100,
                  "snippet": {
                    "text": "strncpy(pi.name, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(), MAX_STR_LEN - 1)",
                    "rendered": {
                      "text": "strncpy(pi.name, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(), MAX_STR_LEN - 1)",
                      "markdown": "`strncpy(pi.name, intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(), MAX_STR_LEN - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18581,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "strcpy_s(pi.name,  MAX_STR_LEN - 1,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18581,
                        "charLength": 100
                      },
                      "insertedContent": {
                        "text": "strlcpy(pi.name,  intf_entry.second.get<std::string>(JKEY_PLANAR_INTF_NAME).c_str(),  MAX_STR_LEN - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dcd9eccc-42aa-4fae-9e3d-b6b953ab900f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 352,
                  "startColumn": 12,
                  "endLine": 352,
                  "endColumn": 96,
                  "charOffset": 14098,
                  "charLength": 84,
                  "snippet": {
                    "text": "memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr)",
                    "rendered": {
                      "text": "memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr)",
                      "markdown": "`memcpy(&planar_intf.ipv4_addr, buffer.data() + offset, sizeof(planar_intf.ipv4_addr)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14098,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&planar_intf.ipv4_addr, <size of &planar_intf.ipv4_addr>,  buffer.data() + offset,  sizeof(planar_intf.ipv4_addr)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7dd95a6-66f0-47c8-9884-ad459d5252a6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 347,
                  "startColumn": 12,
                  "endLine": 347,
                  "endColumn": 86,
                  "charOffset": 13861,
                  "charLength": 74,
                  "snippet": {
                    "text": "memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len)",
                    "rendered": {
                      "text": "memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len)",
                      "markdown": "`memcpy(planar_intf.name, (char*)(buffer.data() + offset), planar_name_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13861,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "memcpy_s(planar_intf.name, <size of planar_intf.name>,  (char*)(buffer.data() + offset),  planar_name_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a86c5718-2b86-47e8-a068-5cf589784fe1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 340,
                  "startColumn": 12,
                  "endLine": 340,
                  "endColumn": 82,
                  "charOffset": 13487,
                  "charLength": 70,
                  "snippet": {
                    "text": "memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len)",
                    "rendered": {
                      "text": "memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len)",
                      "markdown": "`memcpy(planar_intf.id, (char*)(buffer.data() + offset), planar_id_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13487,
                        "charLength": 70
                      },
                      "insertedContent": {
                        "text": "memcpy_s(planar_intf.id, <size of planar_intf.id>,  (char*)(buffer.data() + offset),  planar_id_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-95ada997-f561-446a-86f2-1c1da4bfb4e9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 325,
                  "startColumn": 8,
                  "endLine": 325,
                  "endColumn": 84,
                  "charOffset": 12769,
                  "charLength": 76,
                  "snippet": {
                    "text": "memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip)",
                    "rendered": {
                      "text": "memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip)",
                      "markdown": "`memcpy(&device.virtual_ip, buffer.data() + offset, sizeof(device.virtual_ip)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12769,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&device.virtual_ip, <size of &device.virtual_ip>,  buffer.data() + offset,  sizeof(device.virtual_ip)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7e577a82-b508-4a22-bbec-f9b1cedcf0bb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 320,
                  "startColumn": 8,
                  "endLine": 320,
                  "endColumn": 86,
                  "charOffset": 12550,
                  "charLength": 78,
                  "snippet": {
                    "text": "memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len)",
                    "rendered": {
                      "text": "memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len)",
                      "markdown": "`memcpy(device.virtual_intf, (char*)(buffer.data() + offset), virtual_intf_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12550,
                        "charLength": 78
                      },
                      "insertedContent": {
                        "text": "memcpy_s(device.virtual_intf, <size of device.virtual_intf>,  (char*)(buffer.data() + offset),  virtual_intf_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-771028be-797d-43b7-8c32-555a6e44a2cd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 97,
                  "endLine": 266,
                  "endColumn": 121,
                  "charOffset": 10566,
                  "charLength": 24,
                  "snippet": {
                    "text": "strlen(planar_intf.name)",
                    "rendered": {
                      "text": "strlen(planar_intf.name)",
                      "markdown": "`strlen(planar_intf.name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10566,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10566,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-26783df5-297f-457b-a656-46fa57cdd771",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 264,
                  "startColumn": 45,
                  "endLine": 264,
                  "endColumn": 69,
                  "charOffset": 10319,
                  "charLength": 24,
                  "snippet": {
                    "text": "strlen(planar_intf.name)",
                    "rendered": {
                      "text": "strlen(planar_intf.name)",
                      "markdown": "`strlen(planar_intf.name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10319,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10319,
                        "charLength": 24
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.name, <size of planar_intf.name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c16e4831-efa6-42dd-a4b3-cf59c835a5c3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 261,
                  "startColumn": 93,
                  "endLine": 261,
                  "endColumn": 115,
                  "charOffset": 10195,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(planar_intf.id)",
                    "rendered": {
                      "text": "strlen(planar_intf.id)",
                      "markdown": "`strlen(planar_intf.id)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10195,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10195,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-186f60f6-97bf-4309-becd-2d3f0f527eec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 259,
                  "startColumn": 43,
                  "endLine": 259,
                  "endColumn": 65,
                  "charOffset": 9960,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(planar_intf.id)",
                    "rendered": {
                      "text": "strlen(planar_intf.id)",
                      "markdown": "`strlen(planar_intf.id)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9960,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9960,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(planar_intf.id, <size of planar_intf.id>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d1033a99-0f8f-48a5-8552-599f8da159b9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 246,
                  "startColumn": 99,
                  "endLine": 246,
                  "endColumn": 126,
                  "charOffset": 9339,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(device.virtual_intf)",
                    "rendered": {
                      "text": "strlen(device.virtual_intf)",
                      "markdown": "`strlen(device.virtual_intf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9339,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9339,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ca0e6428-8222-4951-8b6f-decb6b9671fe",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_bootstrap.h"
                },
                "region": {
                  "startLine": 244,
                  "startColumn": 42,
                  "endLine": 244,
                  "endColumn": 69,
                  "charOffset": 9088,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(device.virtual_intf)",
                    "rendered": {
                      "text": "strlen(device.virtual_intf)",
                      "markdown": "`strlen(device.virtual_intf)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9088,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_bootstrap.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9088,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(device.virtual_intf, <size of device.virtual_intf>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d6ecb828-7e6f-45a9-abdf-999292ab3e7a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 488,
                  "startColumn": 37,
                  "endLine": 488,
                  "endColumn": 73,
                  "charOffset": 19613,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(total_LNs * sizeof(pthread_t)",
                    "rendered": {
                      "text": "malloc(total_LNs * sizeof(pthread_t)",
                      "markdown": "`malloc(total_LNs * sizeof(pthread_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19613,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-81523ecc-87f1-4b4d-a75a-4f55bf34ba01",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 489,
                  "startColumn": 62,
                  "endLine": 489,
                  "endColumn": 109,
                  "charOffset": 19714,
                  "charLength": 47,
                  "snippet": {
                    "text": "malloc(total_LNs * sizeof(struct RecvThreadArg)",
                    "rendered": {
                      "text": "malloc(total_LNs * sizeof(struct RecvThreadArg)",
                      "markdown": "`malloc(total_LNs * sizeof(struct RecvThreadArg)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19714,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7f1decfd-9313-45f9-aae3-c6a7b7105c3a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Prohibited strncpy Function Found\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 470,
                  "startColumn": 12,
                  "endLine": 470,
                  "endColumn": 74,
                  "charOffset": 18896,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN)",
                    "rendered": {
                      "text": "strncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN)",
                      "markdown": "`strncpy(connArr[accepted].peer_ip, \"unknown\", INET_ADDRSTRLEN)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18896,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s(connArr[accepted].peer_ip,  INET_ADDRSTRLEN,  \"unknown\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18896,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy(connArr[accepted].peer_ip,  \"unknown\",  INET_ADDRSTRLEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f4ce486f-391e-406d-bf62-9d6118ec11b3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 454,
                  "startColumn": 53,
                  "endLine": 454,
                  "endColumn": 97,
                  "charOffset": 18164,
                  "charLength": 44,
                  "snippet": {
                    "text": "malloc(total_LNs * sizeof(struct Connection)",
                    "rendered": {
                      "text": "malloc(total_LNs * sizeof(struct Connection)",
                      "markdown": "`malloc(total_LNs * sizeof(struct Connection)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18164,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4c9243c7-f02c-420e-bb64-dd51715501c8",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 406,
                  "startColumn": 5,
                  "endLine": 406,
                  "endColumn": 67,
                  "charOffset": 16016,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file))",
                    "rendered": {
                      "text": "strncpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file))",
                      "markdown": "`strncpy(args.ip_list_file, argv[1], sizeof(args.ip_list_file))`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16016,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s(args.ip_list_file,  sizeof(args.ip_list_file,  argv[1])"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 16016,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy(args.ip_list_file,  argv[1],  sizeof(args.ip_list_file)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f7348707-97be-4f68-ba82-f56bdba2a44f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 341,
                  "startColumn": 16,
                  "endLine": 341,
                  "endColumn": 43,
                  "charOffset": 13553,
                  "charLength": 27,
                  "snippet": {
                    "text": "strcpy(root_ip, ip_list[i])",
                    "rendered": {
                      "text": "strcpy(root_ip, ip_list[i])",
                      "markdown": "`strcpy(root_ip, ip_list[i])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13553,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strcpy_s(root_ip, <size of root_ip>,  ip_list[i])"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13553,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlcpy(root_ip,  ip_list[i], <size of root_ip>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8f6d58df-f445-4270-a6de-411bc549333a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 333,
                  "startColumn": 4,
                  "endLine": 333,
                  "endColumn": 31,
                  "charOffset": 13275,
                  "charLength": 27,
                  "snippet": {
                    "text": "strcpy(root_ip, ip_list[0])",
                    "rendered": {
                      "text": "strcpy(root_ip, ip_list[0])",
                      "markdown": "`strcpy(root_ip, ip_list[0])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13275,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strcpy_s(root_ip, <size of root_ip>,  ip_list[0])"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 13275,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlcpy(root_ip,  ip_list[0], <size of root_ip>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fc8644ae-f127-400f-98e6-790ae2b42ee4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 260,
                  "startColumn": 4,
                  "endLine": 260,
                  "endColumn": 58,
                  "charOffset": 10595,
                  "charLength": 54,
                  "snippet": {
                    "text": "strncpy(peer_ip, targ->conn->peer_ip, INET_ADDRSTRLEN)",
                    "rendered": {
                      "text": "strncpy(peer_ip, targ->conn->peer_ip, INET_ADDRSTRLEN)",
                      "markdown": "`strncpy(peer_ip, targ->conn->peer_ip, INET_ADDRSTRLEN)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10595,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strcpy_s(peer_ip,  INET_ADDRSTRLEN,  targ->conn->peer_ip)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10595,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strlcpy(peer_ip,  targ->conn->peer_ip,  INET_ADDRSTRLEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-15760377-ed16-484d-b98f-96dc7eb9884b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 177,
                  "startColumn": 20,
                  "endLine": 177,
                  "endColumn": 64,
                  "charOffset": 7358,
                  "charLength": 44,
                  "snippet": {
                    "text": "strncpy(local_ip, addr_str, INET_ADDRSTRLEN)",
                    "rendered": {
                      "text": "strncpy(local_ip, addr_str, INET_ADDRSTRLEN)",
                      "markdown": "`strncpy(local_ip, addr_str, INET_ADDRSTRLEN)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7358,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strcpy_s(local_ip,  INET_ADDRSTRLEN,  addr_str)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7358,
                        "charLength": 44
                      },
                      "insertedContent": {
                        "text": "strlcpy(local_ip,  addr_str,  INET_ADDRSTRLEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1cb63f91-894d-4329-b1cc-cfb8c9f3f748",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/bootstrap.cc"
                },
                "region": {
                  "startLine": 150,
                  "startColumn": 12,
                  "endLine": 150,
                  "endColumn": 34,
                  "charOffset": 6253,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(ip_list[count])",
                    "rendered": {
                      "text": "strlen(ip_list[count])",
                      "markdown": "`strlen(ip_list[count])`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6253,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(ip_list[count], <size of ip_list[count]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/bootstrap.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6253,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(ip_list[count], <size of ip_list[count]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7c84ab4b-edda-4fdc-9cc4-4977fe4619cc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 2495,
                  "startColumn": 73,
                  "endLine": 2495,
                  "endColumn": 76,
                  "charOffset": 96426,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-fd809644-9ef2-4794-b159-56bf2b0ea79c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 2492,
                  "startColumn": 62,
                  "endLine": 2492,
                  "endColumn": 65,
                  "charOffset": 96254,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0f727ccc-4bbe-4e58-9180-b7bc7089de78",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 2491,
                  "startColumn": 37,
                  "endLine": 2491,
                  "endColumn": 40,
                  "charOffset": 96148,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-3512e1c0-48af-4373-809f-437f345b1066",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 2362,
                  "startColumn": 15,
                  "endLine": 2362,
                  "endColumn": 18,
                  "charOffset": 90915,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b7db5c18-1117-4168-ad5c-26f2db80d52b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 2348,
                  "startColumn": 43,
                  "endLine": 2348,
                  "endColumn": 46,
                  "charOffset": 90491,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-8b284847-06f7-4c1b-9a97-01af54c5820a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 2288,
                  "startColumn": 69,
                  "endLine": 2288,
                  "endColumn": 72,
                  "charOffset": 87513,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b6d4946a-4d20-4017-a2a2-32aeab8d42ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1965,
                  "startColumn": 67,
                  "endLine": 1965,
                  "endColumn": 103,
                  "charOffset": 74780,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(struct ncclIbMrHandle)",
                    "rendered": {
                      "text": "malloc(sizeof(struct ncclIbMrHandle)",
                      "markdown": "`malloc(sizeof(struct ncclIbMrHandle)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74780,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-aa38016f-4c8f-4342-8819-693321a7f18e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1849,
                  "startColumn": 2,
                  "endLine": 1849,
                  "endColumn": 70,
                  "charOffset": 70074,
                  "charLength": 68,
                  "snippet": {
                    "text": "memcpy(stage->buffer, &meta, sizeof(struct ncclIbConnectionMetadata)",
                    "rendered": {
                      "text": "memcpy(stage->buffer, &meta, sizeof(struct ncclIbConnectionMetadata)",
                      "markdown": "`memcpy(stage->buffer, &meta, sizeof(struct ncclIbConnectionMetadata)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 70074,
                        "charLength": 68
                      },
                      "insertedContent": {
                        "text": "memcpy_s(stage->buffer, <size of stage->buffer>,  &meta,  sizeof(struct ncclIbConnectionMetadata)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d49f1007-5643-4757-8fa5-f04c970442c4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1843,
                  "startColumn": 2,
                  "endLine": 1843,
                  "endColumn": 64,
                  "charOffset": 69814,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME)",
                    "rendered": {
                      "text": "strncpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME)",
                      "markdown": "`strncpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69814,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s(meta.devName,  MAX_MERGED_DEV_NAME,  mergedDev->devName)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 69814,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy(meta.devName,  mergedDev->devName,  MAX_MERGED_DEV_NAME)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0b4bd6b8-9e85-4cf2-b30e-48df38060f58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1696,
                  "startColumn": 2,
                  "endLine": 1696,
                  "endColumn": 73,
                  "charOffset": 62393,
                  "charLength": 71,
                  "snippet": {
                    "text": "memcpy(&remMeta, stage->buffer, sizeof(struct ncclIbConnectionMetadata)",
                    "rendered": {
                      "text": "memcpy(&remMeta, stage->buffer, sizeof(struct ncclIbConnectionMetadata)",
                      "markdown": "`memcpy(&remMeta, stage->buffer, sizeof(struct ncclIbConnectionMetadata)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 62393,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&remMeta, <size of &remMeta>,  stage->buffer,  sizeof(struct ncclIbConnectionMetadata)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0d2246c8-e19d-436c-84c3-2954f7b0b5e0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1571,
                  "startColumn": 2,
                  "endLine": 1571,
                  "endColumn": 66,
                  "charOffset": 56964,
                  "charLength": 64,
                  "snippet": {
                    "text": "memcpy(&remMeta, stage->buffer, sizeof(ncclIbConnectionMetadata)",
                    "rendered": {
                      "text": "memcpy(&remMeta, stage->buffer, sizeof(ncclIbConnectionMetadata)",
                      "markdown": "`memcpy(&remMeta, stage->buffer, sizeof(ncclIbConnectionMetadata)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56964,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&remMeta, <size of &remMeta>,  stage->buffer,  sizeof(ncclIbConnectionMetadata)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c1c85b6c-c9b0-43c1-89f6-3ff9db4ed540",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1555,
                  "startColumn": 2,
                  "endLine": 1555,
                  "endColumn": 43,
                  "charOffset": 56337,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(stage->buffer, &meta, sizeof(meta)",
                    "rendered": {
                      "text": "memcpy(stage->buffer, &meta, sizeof(meta)",
                      "markdown": "`memcpy(stage->buffer, &meta, sizeof(meta)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56337,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(stage->buffer, <size of stage->buffer>,  &meta,  sizeof(meta)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c4641aaa-58a6-469d-927a-cc3785df227c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1549,
                  "startColumn": 2,
                  "endLine": 1549,
                  "endColumn": 64,
                  "charOffset": 56145,
                  "charLength": 62,
                  "snippet": {
                    "text": "strncpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME)",
                    "rendered": {
                      "text": "strncpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME)",
                      "markdown": "`strncpy(meta.devName, mergedDev->devName, MAX_MERGED_DEV_NAME)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56145,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strcpy_s(meta.devName,  MAX_MERGED_DEV_NAME,  mergedDev->devName)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 56145,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "strlcpy(meta.devName,  mergedDev->devName,  MAX_MERGED_DEV_NAME)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-694fa5a1-f535-4a28-b373-c098caa3d5ac",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1495,
                  "startColumn": 40,
                  "endLine": 1495,
                  "endColumn": 43,
                  "charOffset": 52914,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0c9f43c1-d7d1-4bf4-938e-fe68123d8ccf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Insecure Cipher Mode Utilized"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 1350,
                  "startColumn": 26,
                  "endLine": 1350,
                  "endColumn": 29,
                  "charOffset": 46698,
                  "charLength": 3,
                  "snippet": {
                    "text": "CTS",
                    "rendered": {
                      "text": "CTS",
                      "markdown": "`CTS`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "Medium",
            "tags": [
              "Cryptography.Symmetric.CipherMode.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-b3bf4982-9007-4b5b-afeb-d5afc4015c6d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 909,
                  "startColumn": 43,
                  "endLine": 909,
                  "endColumn": 55,
                  "charOffset": 33021,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33021,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33021,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5f78e82b-ac5c-46a3-a9bd-d682d8bfcc16",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 909,
                  "startColumn": 24,
                  "endLine": 909,
                  "endColumn": 36,
                  "charOffset": 33002,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33002,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 33002,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fd58669b-ad3e-4ce8-bb50-5cd91cae90a3",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 43,
                  "endLine": 906,
                  "endColumn": 55,
                  "charOffset": 32899,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32899,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32899,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-93578393-2ffc-4b0c-92fb-976443a837cb",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 906,
                  "startColumn": 24,
                  "endLine": 906,
                  "endColumn": 36,
                  "charOffset": 32880,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32880,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32880,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-15e6c2a6-54fb-44cc-a20c-11fc51eb765e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 901,
                  "startColumn": 45,
                  "endLine": 901,
                  "endColumn": 57,
                  "charOffset": 32568,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32568,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32568,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2a913c38-4d2a-485e-bb1a-7eb94800045f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 901,
                  "startColumn": 26,
                  "endLine": 901,
                  "endColumn": 38,
                  "charOffset": 32549,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32549,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32549,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5a3d40c4-f7c5-4515-8264-a467dff9c7dd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 898,
                  "startColumn": 43,
                  "endLine": 898,
                  "endColumn": 55,
                  "charOffset": 32395,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32395,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32395,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c1d98ea8-2b92-4988-b2b8-027681915f41",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 898,
                  "startColumn": 24,
                  "endLine": 898,
                  "endColumn": 36,
                  "charOffset": 32376,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32376,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 32376,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5ad8211d-31f1-40bf-bc1c-fd954e22da0b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 861,
                  "startColumn": 59,
                  "endLine": 861,
                  "endColumn": 102,
                  "charOffset": 30752,
                  "charLength": 43,
                  "snippet": {
                    "text": "strlen(ncclIbMergedDevs[mergedDev].devName)",
                    "rendered": {
                      "text": "strlen(ncclIbMergedDevs[mergedDev].devName)",
                      "markdown": "`strlen(ncclIbMergedDevs[mergedDev].devName)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30752,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strlen_s(ncclIbMergedDevs[mergedDev].devName, <size of ncclIbMergedDevs[mergedDev].devName>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30752,
                        "charLength": 43
                      },
                      "insertedContent": {
                        "text": "strnlen(ncclIbMergedDevs[mergedDev].devName, <size of ncclIbMergedDevs[mergedDev].devName>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4579055c-9f2b-4470-b14b-252ffdeb816c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 854,
                  "startColumn": 12,
                  "endLine": 854,
                  "endColumn": 102,
                  "charOffset": 30294,
                  "charLength": 90,
                  "snippet": {
                    "text": "strncpy(ncclIbMergedDevs[mergedDev].devName, ncclIbDevs[ncclNIbDevs].devName, MAXNAMESIZE)",
                    "rendered": {
                      "text": "strncpy(ncclIbMergedDevs[mergedDev].devName, ncclIbDevs[ncclNIbDevs].devName, MAXNAMESIZE)",
                      "markdown": "`strncpy(ncclIbMergedDevs[mergedDev].devName, ncclIbDevs[ncclNIbDevs].devName, MAXNAMESIZE)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30294,
                        "charLength": 90
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ncclIbMergedDevs[mergedDev].devName,  MAXNAMESIZE,  ncclIbDevs[ncclNIbDevs].devName)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 30294,
                        "charLength": 90
                      },
                      "insertedContent": {
                        "text": "strlcpy(ncclIbMergedDevs[mergedDev].devName,  ncclIbDevs[ncclNIbDevs].devName,  MAXNAMESIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dbe91414-ed64-4503-95a3-cb02e8162f85",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 824,
                  "startColumn": 10,
                  "endLine": 824,
                  "endColumn": 81,
                  "charOffset": 28373,
                  "charLength": 71,
                  "snippet": {
                    "text": "strncpy(ncclIbDevs[ncclNIbDevs].devName, devices[d]->name, MAXNAMESIZE)",
                    "rendered": {
                      "text": "strncpy(ncclIbDevs[ncclNIbDevs].devName, devices[d]->name, MAXNAMESIZE)",
                      "markdown": "`strncpy(ncclIbDevs[ncclNIbDevs].devName, devices[d]->name, MAXNAMESIZE)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28373,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "strcpy_s(ncclIbDevs[ncclNIbDevs].devName,  MAXNAMESIZE,  devices[d]->name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 28373,
                        "charLength": 71
                      },
                      "insertedContent": {
                        "text": "strlcpy(ncclIbDevs[ncclNIbDevs].devName,  devices[d]->name,  MAXNAMESIZE)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0817b320-d21e-4f3c-b18b-310c7bae51bf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 727,
                  "startColumn": 4,
                  "endLine": 727,
                  "endColumn": 55,
                  "charOffset": 24440,
                  "charLength": 51,
                  "snippet": {
                    "text": "strncpy(libPathInfo, \"Unknown\", sizeof(libPathInfo)",
                    "rendered": {
                      "text": "strncpy(libPathInfo, \"Unknown\", sizeof(libPathInfo)",
                      "markdown": "`strncpy(libPathInfo, \"Unknown\", sizeof(libPathInfo)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24440,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "strcpy_s(libPathInfo,  sizeof(libPathInfo,  \"Unknown\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24440,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "strlcpy(libPathInfo,  \"Unknown\",  sizeof(libPathInfo)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-57fea9f0-857d-4864-aa03-697fa9e441ae",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 553,
                  "startColumn": 50,
                  "endLine": 553,
                  "endColumn": 59,
                  "charOffset": 18317,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18317,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18317,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7943bc2e-0159-42a6-95ea-df6af21dd5d6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 724,
                  "startColumn": 4,
                  "endLine": 724,
                  "endColumn": 64,
                  "charOffset": 24284,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy(libPathInfo, pathInfo.dli_fname, sizeof(libPathInfo)",
                    "rendered": {
                      "text": "strncpy(libPathInfo, pathInfo.dli_fname, sizeof(libPathInfo)",
                      "markdown": "`strncpy(libPathInfo, pathInfo.dli_fname, sizeof(libPathInfo)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24284,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s(libPathInfo,  sizeof(libPathInfo,  pathInfo.dli_fname)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24284,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy(libPathInfo,  pathInfo.dli_fname,  sizeof(libPathInfo)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4eeca0c-b583-49c2-af14-a8cb9ec40124",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 702,
                  "startColumn": 2,
                  "endLine": 702,
                  "endColumn": 60,
                  "charOffset": 23392,
                  "charLength": 58,
                  "snippet": {
                    "text": "strncpy(root_host, processor_name, MPI_MAX_PROCESSOR_NAME)",
                    "rendered": {
                      "text": "strncpy(root_host, processor_name, MPI_MAX_PROCESSOR_NAME)",
                      "markdown": "`strncpy(root_host, processor_name, MPI_MAX_PROCESSOR_NAME)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23392,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "strcpy_s(root_host,  MPI_MAX_PROCESSOR_NAME,  processor_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23392,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "strlcpy(root_host,  processor_name,  MPI_MAX_PROCESSOR_NAME)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ea031500-8bd1-4a18-b7ab-d1275e72d06e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Detected Use of Prohibited C Function (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 648,
                  "startColumn": 4,
                  "endLine": 648,
                  "endColumn": 51,
                  "charOffset": 21503,
                  "charLength": 47,
                  "snippet": {
                    "text": "strncpy(args.root_ip, root_ip, INET_ADDRSTRLEN)",
                    "rendered": {
                      "text": "strncpy(args.root_ip, root_ip, INET_ADDRSTRLEN)",
                      "markdown": "`strncpy(args.root_ip, root_ip, INET_ADDRSTRLEN)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21503,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strcpy_s(args.root_ip,  INET_ADDRSTRLEN,  root_ip)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21503,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strlcpy(args.root_ip,  root_ip,  INET_ADDRSTRLEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7227d69-58be-47df-82ac-e131559a6fd6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 553,
                  "startColumn": 33,
                  "endLine": 553,
                  "endColumn": 42,
                  "charOffset": 18300,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18300,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18300,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c540852e-91df-440e-9b8d-c8393e422128",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 551,
                  "startColumn": 6,
                  "endLine": 551,
                  "endColumn": 15,
                  "charOffset": 18185,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(p)",
                    "rendered": {
                      "text": "strlen(p)",
                      "markdown": "`strlen(p)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18185,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18185,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(p, <size of p>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-16cb23c0-0fb6-404d-b3f2-4b9e0f5edeaa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 452,
                  "startColumn": 49,
                  "endLine": 452,
                  "endColumn": 66,
                  "charOffset": 14491,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(\"RoCE v2\")",
                    "rendered": {
                      "text": "strlen(\"RoCE v2\")",
                      "markdown": "`strlen(\"RoCE v2\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14491,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"RoCE v2\", <size of \"RoCE v2\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14491,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(\"RoCE v2\", <size of \"RoCE v2\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1e120aff-c367-4123-9038-95f839fc8caa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 450,
                  "startColumn": 109,
                  "endLine": 450,
                  "endColumn": 126,
                  "charOffset": 14395,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(\"RoCE v1\")",
                    "rendered": {
                      "text": "strlen(\"RoCE v1\")",
                      "markdown": "`strlen(\"RoCE v1\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14395,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"RoCE v1\", <size of \"RoCE v1\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14395,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(\"RoCE v1\", <size of \"RoCE v1\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a30b7957-b057-449f-b664-02c0da738756",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 450,
                  "startColumn": 45,
                  "endLine": 450,
                  "endColumn": 65,
                  "charOffset": 14331,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(\"IB/RoCE v1\")",
                    "rendered": {
                      "text": "strlen(\"IB/RoCE v1\")",
                      "markdown": "`strlen(\"IB/RoCE v1\")`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14331,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"IB/RoCE v1\", <size of \"IB/RoCE v1\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14331,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(\"IB/RoCE v1\", <size of \"IB/RoCE v1\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3759f893-b86a-4628-a0d9-eb68dbbf670b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 449,
                  "startColumn": 6,
                  "endLine": 449,
                  "endColumn": 27,
                  "charOffset": 14261,
                  "charLength": 21,
                  "snippet": {
                    "text": "strlen(gidRoceVerStr)",
                    "rendered": {
                      "text": "strlen(gidRoceVerStr)",
                      "markdown": "`strlen(gidRoceVerStr)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14261,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "strlen_s(gidRoceVerStr, <size of gidRoceVerStr>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14261,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "strnlen(gidRoceVerStr, <size of gidRoceVerStr>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-20958ea5-3839-4381-9b00-1ccefc8c1c1b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 329,
                  "startColumn": 21,
                  "endLine": 329,
                  "endColumn": 32,
                  "charOffset": 10597,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(env)",
                    "rendered": {
                      "text": "strlen(env)",
                      "markdown": "`strlen(env)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10597,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(env, <size of env>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10597,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(env, <size of env>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-08890470-54ca-4576-80f3-d21c3aa6183a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/net_ib.cc"
                },
                "region": {
                  "startLine": 307,
                  "startColumn": 21,
                  "endLine": 307,
                  "endColumn": 32,
                  "charOffset": 10061,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(env)",
                    "rendered": {
                      "text": "strlen(env)",
                      "markdown": "`strlen(env)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10061,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(env, <size of env>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/net_ib.cc"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10061,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(env, <size of env>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc4893f5-b3c2-425d-8b88-506bdc7bd7be",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/anp_param.h"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 15,
                  "endLine": 25,
                  "endColumn": 26,
                  "charOffset": 884,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(str)",
                    "rendered": {
                      "text": "strlen(str)",
                      "markdown": "`strlen(str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_param.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 884,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/anp_param.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 884,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(str, <size of str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}